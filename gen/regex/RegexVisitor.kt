/**
This code is generated by [translate.codegen.VisitorBuilder] derived from [translate.meta.MetaVisitorBase] 
generated by [translate.codegen.VisitorBaseBuilder]
basing on grammar description [regex.RegexGrammarInfo] derived from [translate.codegen.helpers.GrammarInfo]
*/

package regex

import grammar.token.Token
import grammar.Grammar
import grammar.Expansion
import utils.Beautifier

import structure.ASTNode
import structure.Visitor

import regex.RegexGrammarInfo

@Suppress("UNCHECKED_CAST")
object RegexVisitor : Visitor<RegexData, RegexData> {

/*
Start: regex
regex -> sequence regexPlus
regexPlus -> CHOICE regex | <eps>
sequence -> term sequencePlus
sequencePlus -> sequence | <eps>
term -> atom number closure
number -> UINT | <eps>
closure -> KLEENE closure | <eps>
atom -> LPAREN regex RPAREN | ALPHA
*/

    override fun <T : Token> collect(root: ASTNode<T>): RegexData {
        return visit(root, RegexData())
    }


    fun <T : Token> visitTerminal(token: T): RegexData {
        return RegexData()
    }

    override fun visit(node: ASTNode<out Token>, value: RegexData): RegexData {
        return when(node.getToken()) {
            RegexGrammarInfo.LPAREN -> visit_LPAREN(node as ASTNode.TerminalNode<RegexGrammarInfo.LPAREN>, value)
            RegexGrammarInfo.RPAREN -> visit_RPAREN(node as ASTNode.TerminalNode<RegexGrammarInfo.RPAREN>, value)
            RegexGrammarInfo.KLEENE -> visit_KLEENE(node as ASTNode.TerminalNode<RegexGrammarInfo.KLEENE>, value)
            RegexGrammarInfo.CHOICE -> visit_CHOICE(node as ASTNode.TerminalNode<RegexGrammarInfo.CHOICE>, value)
            RegexGrammarInfo.ALPHA -> visit_ALPHA(node as ASTNode.TerminalNode<Token.VariantToken.VariantInstanceToken<RegexGrammarInfo.ALPHA>>, value)
            RegexGrammarInfo.UINT -> visit_UINT(node as ASTNode.TerminalNode<Token.VariantToken.VariantInstanceToken<RegexGrammarInfo.UINT>>, value)
            RegexGrammarInfo.regex -> visit_regex(node as ASTNode.InnerNode<RegexGrammarInfo.regex>, value)
            RegexGrammarInfo.regexPlus -> visit_regexPlus(node as ASTNode.InnerNode<RegexGrammarInfo.regexPlus>, value)
            RegexGrammarInfo.sequence -> visit_sequence(node as ASTNode.InnerNode<RegexGrammarInfo.sequence>, value)
            RegexGrammarInfo.sequencePlus -> visit_sequencePlus(node as ASTNode.InnerNode<RegexGrammarInfo.sequencePlus>, value)
            RegexGrammarInfo.term -> visit_term(node as ASTNode.InnerNode<RegexGrammarInfo.term>, value)
            RegexGrammarInfo.number -> visit_number(node as ASTNode.InnerNode<RegexGrammarInfo.number>, value)
            RegexGrammarInfo.closure -> visit_closure(node as ASTNode.InnerNode<RegexGrammarInfo.closure>, value)
            RegexGrammarInfo.atom -> visit_atom(node as ASTNode.InnerNode<RegexGrammarInfo.atom>, value)
            else -> throw IllegalStateException("Unknown token ${node.getToken()} met")
        }
    }

    fun visit_LPAREN(node: ASTNode.TerminalNode<RegexGrammarInfo.LPAREN>, value: RegexData): RegexData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_RPAREN(node: ASTNode.TerminalNode<RegexGrammarInfo.RPAREN>, value: RegexData): RegexData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_KLEENE(node: ASTNode.TerminalNode<RegexGrammarInfo.KLEENE>, value: RegexData): RegexData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_CHOICE(node: ASTNode.TerminalNode<RegexGrammarInfo.CHOICE>, value: RegexData): RegexData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_ALPHA(node: ASTNode.TerminalNode<Token.VariantToken.VariantInstanceToken<RegexGrammarInfo.ALPHA>>, value: RegexData): RegexData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_UINT(node: ASTNode.TerminalNode<Token.VariantToken.VariantInstanceToken<RegexGrammarInfo.UINT>>, value: RegexData): RegexData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    /**
    regex -> sequence regexPlus
    */
    fun visit_regex(node: ASTNode.InnerNode<RegexGrammarInfo.regex>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()
        children.add(visit_sequence(node.getChild(0), RegexData()))
        children.add(visit_regexPlus(node.getChild(1), RegexData()))

        return value
    }

    fun visit_regexPlus(node: ASTNode.InnerNode<RegexGrammarInfo.regexPlus>, value: RegexData): RegexData {
        return when (val id = node.getExpansion().getId()) {
            0 -> visit_regexPlus_0(node, value)
            1 -> visit_regexPlus_1(node, value)
            else -> throw IllegalStateException("Unexpected expansion id $id in expansion of regexPlus")
        }
    }

    /**
    regexPlus -> CHOICE regex
    */
    fun visit_regexPlus_0(node: ASTNode.InnerNode<RegexGrammarInfo.regexPlus>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()
        children.add(visit_CHOICE(node.getChild(0), RegexData()))
        children.add(visit_regex(node.getChild(1), RegexData()))

        return value
    }

    /**
    regexPlus -> <eps>
    */
    fun visit_regexPlus_1(node: ASTNode.InnerNode<RegexGrammarInfo.regexPlus>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()


        return value
    }

    /**
    sequence -> term sequencePlus
    */
    fun visit_sequence(node: ASTNode.InnerNode<RegexGrammarInfo.sequence>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()
        children.add(visit_term(node.getChild(0), RegexData()))
        children.add(visit_sequencePlus(node.getChild(1), RegexData()))

        return value
    }

    fun visit_sequencePlus(node: ASTNode.InnerNode<RegexGrammarInfo.sequencePlus>, value: RegexData): RegexData {
        return when (val id = node.getExpansion().getId()) {
            0 -> visit_sequencePlus_0(node, value)
            1 -> visit_sequencePlus_1(node, value)
            else -> throw IllegalStateException("Unexpected expansion id $id in expansion of sequencePlus")
        }
    }

    /**
    sequencePlus -> sequence
    */
    fun visit_sequencePlus_0(node: ASTNode.InnerNode<RegexGrammarInfo.sequencePlus>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()
        children.add(visit_sequence(node.getChild(0), RegexData()))

        return value
    }

    /**
    sequencePlus -> <eps>
    */
    fun visit_sequencePlus_1(node: ASTNode.InnerNode<RegexGrammarInfo.sequencePlus>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()


        return value
    }

    /**
    term -> atom number closure
    */
    fun visit_term(node: ASTNode.InnerNode<RegexGrammarInfo.term>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()
        children.add(visit_atom(node.getChild(0), RegexData()))
        children.add(visit_number(node.getChild(1), RegexData()))
        children.add(visit_closure(node.getChild(2), RegexData()))

        return value
    }

    fun visit_number(node: ASTNode.InnerNode<RegexGrammarInfo.number>, value: RegexData): RegexData {
        return when (val id = node.getExpansion().getId()) {
            0 -> visit_number_0(node, value)
            1 -> visit_number_1(node, value)
            else -> throw IllegalStateException("Unexpected expansion id $id in expansion of number")
        }
    }

    /**
    number -> UINT
    */
    fun visit_number_0(node: ASTNode.InnerNode<RegexGrammarInfo.number>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()
        children.add(visit_UINT(node.getChild(0), RegexData()))

        return value
    }

    /**
    number -> <eps>
    */
    fun visit_number_1(node: ASTNode.InnerNode<RegexGrammarInfo.number>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()


        return value
    }

    fun visit_closure(node: ASTNode.InnerNode<RegexGrammarInfo.closure>, value: RegexData): RegexData {
        return when (val id = node.getExpansion().getId()) {
            0 -> visit_closure_0(node, value)
            1 -> visit_closure_1(node, value)
            else -> throw IllegalStateException("Unexpected expansion id $id in expansion of closure")
        }
    }

    /**
    closure -> KLEENE closure
    */
    fun visit_closure_0(node: ASTNode.InnerNode<RegexGrammarInfo.closure>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()
        children.add(visit_KLEENE(node.getChild(0), RegexData()))
        children.add(visit_closure(node.getChild(1), RegexData()))

        return value
    }

    /**
    closure -> <eps>
    */
    fun visit_closure_1(node: ASTNode.InnerNode<RegexGrammarInfo.closure>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()


        return value
    }

    fun visit_atom(node: ASTNode.InnerNode<RegexGrammarInfo.atom>, value: RegexData): RegexData {
        return when (val id = node.getExpansion().getId()) {
            0 -> visit_atom_0(node, value)
            1 -> visit_atom_1(node, value)
            else -> throw IllegalStateException("Unexpected expansion id $id in expansion of atom")
        }
    }

    /**
    atom -> LPAREN regex RPAREN
    */
    fun visit_atom_0(node: ASTNode.InnerNode<RegexGrammarInfo.atom>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()
        children.add(visit_LPAREN(node.getChild(0), RegexData()))
        children.add(visit_regex(node.getChild(1), RegexData()))
        children.add(visit_RPAREN(node.getChild(2), RegexData()))

        return value
    }

    /**
    atom -> ALPHA
    */
    fun visit_atom_1(node: ASTNode.InnerNode<RegexGrammarInfo.atom>, value: RegexData): RegexData {
        val children = mutableListOf<RegexData>()
        children.add(visit_ALPHA(node.getChild(0), RegexData()))

        return value
    }

}