/**
This code is generated by [translate.codegen.VisitorBuilder] derived from [translate.meta.MetaVisitorBase] 
generated by [translate.meta.helpers.MetaVisitorBuilder]
basing on grammar description [calculator.CalculatorGrammarInfo] derived from [translate.codegen.helpers.GrammarInfo]
*/

package calculator

import grammar.token.Token
import grammar.Grammar
import grammar.Expansion
import utils.Beautifier

import structure.ASTNode
import structure.Visitor

import calculator.CalculatorGrammarInfo

@Suppress("UNCHECKED_CAST")
object CalculatorVisitor : Visitor<CalculatorData, CalculatorData> {

/*
Start: expression
expression -> term expressionPlus
expressionPlus -> PLUS term expressionPlus | MINUS term expressionPlus | <eps>
term -> factor termPlus
termPlus -> TIMES factor termPlus | DIV factor termPlus | <eps>
factor -> MINUS factor | atom
atom -> LPAREN expression RPAREN | UINT
*/

    override fun <T : Token> collect(root: ASTNode<T>): CalculatorData {
        return visit(root, CalculatorData())
    }


    fun <T : Token> visitTerminal(token: T): CalculatorData {
        return CalculatorData()
    }

    override fun visit(node: ASTNode<out Token>, value: CalculatorData): CalculatorData {
        return when(node.getToken()) {
            CalculatorGrammarInfo.WHITESPACE -> visit_WHITESPACE(node as ASTNode.TerminalNode<Token.VariantToken.VariantInstanceToken<CalculatorGrammarInfo.WHITESPACE>>, value)
            CalculatorGrammarInfo.LPAREN -> visit_LPAREN(node as ASTNode.TerminalNode<CalculatorGrammarInfo.LPAREN>, value)
            CalculatorGrammarInfo.RPAREN -> visit_RPAREN(node as ASTNode.TerminalNode<CalculatorGrammarInfo.RPAREN>, value)
            CalculatorGrammarInfo.PLUS -> visit_PLUS(node as ASTNode.TerminalNode<CalculatorGrammarInfo.PLUS>, value)
            CalculatorGrammarInfo.MINUS -> visit_MINUS(node as ASTNode.TerminalNode<CalculatorGrammarInfo.MINUS>, value)
            CalculatorGrammarInfo.TIMES -> visit_TIMES(node as ASTNode.TerminalNode<CalculatorGrammarInfo.TIMES>, value)
            CalculatorGrammarInfo.DIV -> visit_DIV(node as ASTNode.TerminalNode<CalculatorGrammarInfo.DIV>, value)
            CalculatorGrammarInfo.UINT -> visit_UINT(node as ASTNode.TerminalNode<Token.VariantToken.VariantInstanceToken<CalculatorGrammarInfo.UINT>>, value)
            CalculatorGrammarInfo.expression -> visit_expression(node as ASTNode.InnerNode<CalculatorGrammarInfo.expression>, value)
            CalculatorGrammarInfo.expressionPlus -> visit_expressionPlus(node as ASTNode.InnerNode<CalculatorGrammarInfo.expressionPlus>, value)
            CalculatorGrammarInfo.term -> visit_term(node as ASTNode.InnerNode<CalculatorGrammarInfo.term>, value)
            CalculatorGrammarInfo.termPlus -> visit_termPlus(node as ASTNode.InnerNode<CalculatorGrammarInfo.termPlus>, value)
            CalculatorGrammarInfo.factor -> visit_factor(node as ASTNode.InnerNode<CalculatorGrammarInfo.factor>, value)
            CalculatorGrammarInfo.atom -> visit_atom(node as ASTNode.InnerNode<CalculatorGrammarInfo.atom>, value)
            else -> throw IllegalStateException("Unknown token ${node.getToken()} met")
        }
    }

    fun visit_WHITESPACE(node: ASTNode.TerminalNode<Token.VariantToken.VariantInstanceToken<CalculatorGrammarInfo.WHITESPACE>>, value: CalculatorData): CalculatorData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_LPAREN(node: ASTNode.TerminalNode<CalculatorGrammarInfo.LPAREN>, value: CalculatorData): CalculatorData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_RPAREN(node: ASTNode.TerminalNode<CalculatorGrammarInfo.RPAREN>, value: CalculatorData): CalculatorData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_PLUS(node: ASTNode.TerminalNode<CalculatorGrammarInfo.PLUS>, value: CalculatorData): CalculatorData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_MINUS(node: ASTNode.TerminalNode<CalculatorGrammarInfo.MINUS>, value: CalculatorData): CalculatorData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_TIMES(node: ASTNode.TerminalNode<CalculatorGrammarInfo.TIMES>, value: CalculatorData): CalculatorData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_DIV(node: ASTNode.TerminalNode<CalculatorGrammarInfo.DIV>, value: CalculatorData): CalculatorData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    fun visit_UINT(node: ASTNode.TerminalNode<Token.VariantToken.VariantInstanceToken<CalculatorGrammarInfo.UINT>>, value: CalculatorData): CalculatorData {
        return visitTerminal(node.getToken()).also { it.text = node.getToken().getText() }
    }

    /**
    expression -> term expressionPlus
    */
    fun visit_expression(node: ASTNode.InnerNode<CalculatorGrammarInfo.expression>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()
        children.add(visit_term(node.getChild(0), CalculatorData()))
        children.add(visit_expressionPlus(node.getChild(1), CalculatorData(left = children[0].value)))
        value.value = children[1].value
        return value
    }

    fun visit_expressionPlus(node: ASTNode.InnerNode<CalculatorGrammarInfo.expressionPlus>, value: CalculatorData): CalculatorData {
        return when (val id = node.getExpansion().getId()) {
            0 -> visit_expressionPlus_0(node, value)
            1 -> visit_expressionPlus_1(node, value)
            2 -> visit_expressionPlus_2(node, value)
            else -> throw IllegalStateException("Unexpected expansion id $id in expansion of expressionPlus")
        }
    }

    /**
    expressionPlus -> PLUS term expressionPlus
    */
    fun visit_expressionPlus_0(node: ASTNode.InnerNode<CalculatorGrammarInfo.expressionPlus>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()
        children.add(visit_PLUS(node.getChild(0), CalculatorData()))
        children.add(visit_term(node.getChild(1), CalculatorData()))
        children.add(visit_expressionPlus(node.getChild(2), CalculatorData(left = value.left + children[1].value)))
        value.value = children[2].value
        return value
    }

    /**
    expressionPlus -> MINUS term expressionPlus
    */
    fun visit_expressionPlus_1(node: ASTNode.InnerNode<CalculatorGrammarInfo.expressionPlus>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()
        children.add(visit_MINUS(node.getChild(0), CalculatorData()))
        children.add(visit_term(node.getChild(1), CalculatorData()))
        children.add(visit_expressionPlus(node.getChild(2), CalculatorData(left = value.left - children[1].value)))
        value.value = children[2].value
        return value
    }

    /**
    expressionPlus -> <eps>
    */
    fun visit_expressionPlus_2(node: ASTNode.InnerNode<CalculatorGrammarInfo.expressionPlus>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()

        value.value = value.left
        return value
    }

    /**
    term -> factor termPlus
    */
    fun visit_term(node: ASTNode.InnerNode<CalculatorGrammarInfo.term>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()
        children.add(visit_factor(node.getChild(0), CalculatorData()))
        children.add(visit_termPlus(node.getChild(1), CalculatorData(left = children[0].value)))
        value.value = children[1].value
        return value
    }

    fun visit_termPlus(node: ASTNode.InnerNode<CalculatorGrammarInfo.termPlus>, value: CalculatorData): CalculatorData {
        return when (val id = node.getExpansion().getId()) {
            0 -> visit_termPlus_0(node, value)
            1 -> visit_termPlus_1(node, value)
            2 -> visit_termPlus_2(node, value)
            else -> throw IllegalStateException("Unexpected expansion id $id in expansion of termPlus")
        }
    }

    /**
    termPlus -> TIMES factor termPlus
    */
    fun visit_termPlus_0(node: ASTNode.InnerNode<CalculatorGrammarInfo.termPlus>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()
        children.add(visit_TIMES(node.getChild(0), CalculatorData()))
        children.add(visit_factor(node.getChild(1), CalculatorData()))
        children.add(visit_termPlus(node.getChild(2), CalculatorData(left = value.left * children[1].value)))
        value.value = children[2].value
        return value
    }

    /**
    termPlus -> DIV factor termPlus
    */
    fun visit_termPlus_1(node: ASTNode.InnerNode<CalculatorGrammarInfo.termPlus>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()
        children.add(visit_DIV(node.getChild(0), CalculatorData()))
        children.add(visit_factor(node.getChild(1), CalculatorData()))
        children.add(visit_termPlus(node.getChild(2), CalculatorData(left = value.left / children[1].value)))
        value.value = children[2].value
        return value
    }

    /**
    termPlus -> <eps>
    */
    fun visit_termPlus_2(node: ASTNode.InnerNode<CalculatorGrammarInfo.termPlus>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()

        value.value = value.left
        return value
    }

    fun visit_factor(node: ASTNode.InnerNode<CalculatorGrammarInfo.factor>, value: CalculatorData): CalculatorData {
        return when (val id = node.getExpansion().getId()) {
            0 -> visit_factor_0(node, value)
            1 -> visit_factor_1(node, value)
            else -> throw IllegalStateException("Unexpected expansion id $id in expansion of factor")
        }
    }

    /**
    factor -> MINUS factor
    */
    fun visit_factor_0(node: ASTNode.InnerNode<CalculatorGrammarInfo.factor>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()
        children.add(visit_MINUS(node.getChild(0), CalculatorData()))
        children.add(visit_factor(node.getChild(1), CalculatorData()))
        value.value = -children[1].value
        return value
    }

    /**
    factor -> atom
    */
    fun visit_factor_1(node: ASTNode.InnerNode<CalculatorGrammarInfo.factor>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()
        children.add(visit_atom(node.getChild(0), CalculatorData()))
        value.value = children[0].value
        return value
    }

    fun visit_atom(node: ASTNode.InnerNode<CalculatorGrammarInfo.atom>, value: CalculatorData): CalculatorData {
        return when (val id = node.getExpansion().getId()) {
            0 -> visit_atom_0(node, value)
            1 -> visit_atom_1(node, value)
            else -> throw IllegalStateException("Unexpected expansion id $id in expansion of atom")
        }
    }

    /**
    atom -> LPAREN expression RPAREN
    */
    fun visit_atom_0(node: ASTNode.InnerNode<CalculatorGrammarInfo.atom>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()
        children.add(visit_LPAREN(node.getChild(0), CalculatorData()))
        children.add(visit_expression(node.getChild(1), CalculatorData()))
        children.add(visit_RPAREN(node.getChild(2), CalculatorData()))
        value.value = children[1].value
        return value
    }

    /**
    atom -> UINT
    */
    fun visit_atom_1(node: ASTNode.InnerNode<CalculatorGrammarInfo.atom>, value: CalculatorData): CalculatorData {
        val children = mutableListOf<CalculatorData>()
        children.add(visit_UINT(node.getChild(0), CalculatorData()))
        value.value = CalculatorData.Macro.toInt(children[0].text)
        return value
    }

}