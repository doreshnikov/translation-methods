package translate.codegen

import grammar.token.Token
import structure.Description
import utils.Beautifier.Companion.detabify
import java.io.File

class VisitorBuilder(
    private val description: Description,
    private val name: String,
    private val packageName: String,
    private val className: String
) {

    val tokens = Token.REGISTERED.all().filter { it !is Token.UniqueToken }

    fun buildVisitor(output: File) {
        output.bufferedWriter().use { out ->
            out.write(
                detabify(
                    """/**
This code is generated by [translate.codegen.VisitorBuilder] by provided [structure.Description]
*/

package $packageName

import structure.Visitor
import structure.ASTNode
import grammar.token.Token
import $packageName.$name

@Suppress("UNCHECKED_CAST")
abstract class $className<R> : Visitor<R> {

/*
${description.getGrammar()}
*/

    override fun visit(node: ASTNode<out Token>): R {${collectChoiceVisit()}
    }
    
    abstract fun <T : Token> visitTerminal(token: T): R
    
${collectVisitMethods()}

}
"""
                )
            )
        }
    }

    private fun nodeType(token: Token): String {
        return when (token) {
            is Token.StateToken -> "ASTNode.InnerNode<${fullName(token)}>"
            is Token.DataToken -> "ASTNode.TerminalNode<${fullName(token)}>"
            is Token.VariantToken -> "ASTNode.TerminalNode<Token.VariantToken.VariantInstanceToken<${fullName(token)}>>"
            else -> throw IllegalArgumentException("Unexpected token $token type")
        }
    }

    private fun fullName(token: Token): String {
        return "$name.$token"
    }

    private fun collectChoiceVisit(): String {
        return """
        return when(node.getToken()) {
${tokens.joinToString("\n") { token ->
            "\t\t\t${fullName(token)} -> visit_${token}(node as ${nodeType(token)})"
        }}
            else -> throw IllegalStateException("Unknown token ${"$"}{node.getToken()} met")
        }"""
    }

    private fun visitStateMethod(token: Token.StateToken): String {
        val expansions = description.getGrammar().RULES[token].expansions
        return if (expansions.size == 1) {
            """
    /**
    $token -> ${expansions.first()}
    */
    abstract fun visit_${token}(node: ${nodeType(token)}): R
"""
        } else {
            """
    fun visit_${token}(node: ${nodeType(token)}): R {
        return when (val id = node.getExpansion().getId()) {
${expansions.joinToString("\n") { "\t\t\t${it.getId()} -> visit_${token}_${it.getId()}(node)" }}
            else -> throw IllegalStateException("Unexpected expansion id ${"$"}id in expansion of ${token}")
        }
    }
${expansions.joinToString("\n") {
                """
    /**
    $token -> $it
    */
    abstract fun visit_${token}_${it.getId()}(node: ${nodeType(token)}): R"""
            }}"""
        }
    }

    private fun visitTerminalMethod(token: Token): String {
        return "\topen fun visit_${token}(node: ${nodeType(token)}): R " +
                "{\n\t\treturn visitTerminal(node.getToken())\n\t}"
    }

    private fun collectVisitMethods(): String {
        return tokens.joinToString("\n") { token ->
            when (token) {
                is Token.StateToken -> visitStateMethod(token)
                else -> visitTerminalMethod(token)
            }
        }
    }

}