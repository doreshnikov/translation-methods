package translate.codegen

import grammar.Expansion
import grammar.Grammar
import grammar.token.Token
import structure.ASTNode
import structure.Visitor
import translate.codegen.info.GrammarInfo
import translate.codegen.info.VisitorInfo
import translate.meta.grammar.MetaGrammarInfo
import translate.meta.visitors.MetaVisitorInfo
import translate.meta.visitors.MetaVisitorBase
import translate.test.loc
import utils.Beautifier
import java.io.File

class VisitorInfoBuilder(
    private val packageName: String,
    private val objectName: String,
    private val grammarInfoObjectName: String
) : MetaVisitorBase<String> {

    private val packagePath = packageName.replace(".", "\\")

    fun <T : Token> doAll(root: ASTNode<T>) {
        val path = "$loc\\src\\$packagePath"
        File("$path\\$objectName.kt").bufferedWriter().use { out -> out.write(collect(root)) }
    }

    override fun <T : Token> visitTerminal(token: T): String {
        return token.getText()
    }

    override fun <T : Token> collect(root: ASTNode<T>): String {
        val collected = visit(root)
        return Beautifier.detabify(
            """/**
This code is generated by [${VisitorInfoBuilder::class.qualifiedName}]
deriving from base class [${MetaVisitorBase::class.qualifiedName}] generated by [${MetaVisitorInfo::class.qualifiedName}]
*/

package $packageName

import ${Token::class.qualifiedName}
import ${Grammar::class.qualifiedName}
import ${Expansion::class.qualifiedName}
import ${Beautifier::class.qualifiedName}

import ${ASTNode::class.qualifiedName}
import ${Visitor::class.qualifiedName}

import ${VisitorInfo::class.qualifiedName}
import ${GrammarInfo::class.qualifiedName}

object $objectName : ${VisitorInfo::class.simpleName} {

    val grammarInfo = $grammarInfoObjectName
    val packageName = "$packageName"
    val className = "${objectName}Generated"
    
    override fun getDefinedTokens(): List<${Token::class.simpleName}> {
        return grammarInfo.getDefinedTokens()
    }
    
    override fun getFullName(token: ${Token::class.simpleName}): String {
        return "${"$"}{$grammarInfoObjectName.getName()}.${"$"}token"
    }
    
    override fun getNodeType(token: ${Token::class.simpleName}): String {
        return when (token) {
            is ${Token::class.simpleName}.${Token.StateToken::class.simpleName} -> 
                "${objectName}InnerNode<${"$"}{getFullName(token)}>"
            is ${Token::class.simpleName}.${Token.DataToken::class.simpleName} -> 
                "${objectName}TerminalNode<${"$"}{getFullName(token)}>"
            is ${Token::class.simpleName}.${Token.VariantToken::class.simpleName} -> 
                "${"${objectName}TerminalNode<${Token::class.simpleName}" +
                    ".${Token.VariantToken::class.simpleName}" +
                    ".${Token.VariantToken.VariantInstanceToken::class.simpleName}" +
                    "<${"$"}{getFullName(token)}>>"}"
            else -> throw IllegalArgumentException("Unexpected token ${"$"}token type")
        }
    }
    
    override fun getVisitMethods(token: ${Token::class.simpleName}): String {
        return when (token) {
            is ${Token::class.simpleName}.${Token.StateToken::class.simpleName} -> getStateVisitMethods(token)
            else -> getTerminalVisitMethods(token)
        }
    }
    
    private fun getStateVisitMethods(token: ${Token::class.simpleName}.${Token.StateToken::class.simpleName}): String {
        val expansions = grammarInfo.getGrammar().RULES[token].expansions
        return if (expansions.size == 1) {
            ""${'"'}
    /**
    ${"$"}token -> ${"$"}{expansions.first()}
    */
    fun visit_${"$"}{token}(node: ${"$"}{getNodeType(token)}): R ""${'"'}
        } else {
            ""${'"'}
    fun visit_${"$"}{token}(node: ${"$"}{getNodeType(token)}): R {
        return when (val id = node.getExpansion().getId()) {
${"$"}{expansions.joinToString("\n") { "\t\t\t${"$"}{it.getId()} -> visit_${"$"}{token}_${"$"}{it.getId()}(node)" }}
            else -> throw IllegalStateException("Unexpected expansion id ${"$"}{"${"$"}"}id in expansion of ${"$"}token")
        }
    }
${"$"}{expansions.joinToString("\n") {
                ""${'"'}
    /**
    ${"$"}token -> ${"$"}it
    */
    fun visit_${"$"}{token}_${"$"}{it.getId()}(node: ${"$"}{getNodeType(token)}): R""${'"'}
            }}""${'"'}
        }
    }

    private fun getTerminalVisitMethods(token: Token): String {
        return ""${'"'}
    fun visit_${"$"}{token}(node: ${"$"}{getNodeType(token)}): R {
        return visitTerminal(node.getToken())
    }""${'"'}
    }
    
    override fun getAll(): String {
        return Beautifier.detabify(
            ""${'"'}/**
This code is generated by [${"$"}{$objectName::class.qualifiedName}] derived from [${"$"}{VisitorInfo::class.qualifiedName}]
based on grammar description [${"$"}{$grammarInfoObjectName::class.qualifiedName}] derived from [${"$"}{GrammarInfo::class.qualifiedName}]
*/

package ${"$"}packageName

import ${"$"}{Visitor::class.qualifiedName}
import ${"$"}{ASTNode::class.qualifiedName}
import ${"$"}{Token::class.qualifiedName}
import ${"$"}packageName.${"$"}{grammarInfo.getName()}

@Suppress("UNCHECKED_CAST")
interface ${"$"}className<R> : ${"$"}{Visitor::class.simpleName}<R> {

/*
${"$"}{grammarInfo.getGrammar()}
*/

    override fun visit(node: ${ASTNode::class.simpleName}<out ${Token::class.simpleName}>): R {${"$"}{getChoiceVisit()}
    }
    
    fun <T : ${Token::class.simpleName}> visitTerminal(token: T): R
    
${"$"}{getVisitMethods()}

}""${'"'}
        )
    }
    
$collected
}
"""
        )
    }

    /**
    all -> m t g
     */
    override fun visit_all(node: ASTNode.InnerNode<MetaGrammarInfo.all>): String {
        return ""
    }

}