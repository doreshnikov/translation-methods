/**
This code is generated by [translate.codegen.VisitorInfoBuilder]
deriving from base class [translate.meta.MetaBaseVisitor] generated by [translate.meta.MetaVisitorInfo]
*/

package gen

import java.io.File

import grammar.token.Token
import grammar.Grammar
import grammar.Expansion
import utils.Beautifier

import structure.ASTNode
import structure.Visitor

import translate.codegen.info.VisitorInfo
import translate.codegen.info.GrammarInfo

class PrefixVisitorInfoData() {


}
    
class PrefixVisitorInfoTerminalNode<T : Token>(token: T) : 
    ASTNode.TerminalNode<T>(token) {
    val data = PrefixVisitorInfoData()
}
    
class PrefixVisitorInfoInnerNode<T : Token>(token: T, expansion: Expansion) : 
    ASTNode.InnerNode<T>(token, expansion) {
    val data = PrefixVisitorInfoData()    
}

fun main() {
    File("C:\\Users\\jetbrains\\IdeaProjects\\translation-methods\\src\\gen\\PrefixVisitorInfoGenerated.kt").bufferedWriter().use { out ->
        out.write(PrefixVisitorInfo.getAll())
    }
}

object PrefixVisitorInfo : VisitorInfo {

    private val grammarInfo = PrefixGrammarInfo
    private val packageName = "gen"
    private val className = "PrefixVisitorInfoGenerated"
    
    override fun getDefinedTokens(): List<Token> {
        return grammarInfo.getDefinedTokens()
    }
    
    override fun getFullName(token: Token): String {
        return "${PrefixGrammarInfo.getName()}.$token"
    }
    
    override fun getNodeType(token: Token): String {
        return when (token) {
            is Token.StateToken -> 
                "PrefixVisitorInfoInnerNode<${getFullName(token)}>"
            is Token.DataToken -> 
                "PrefixVisitorInfoTerminalNode<${getFullName(token)}>"
            is Token.VariantToken -> 
                "PrefixVisitorInfoTerminalNode<Token.VariantToken.VariantInstanceToken<${getFullName(token)}>>"
            else -> throw IllegalArgumentException("Unexpected token $token type")
        }
    }
    
    override fun getVisitMethods(token: Token): String {
        return when (token) {
            is Token.StateToken -> getStateVisitMethods(token)
            else -> getTerminalVisitMethods(token)
        }
    }
    
    private fun getStateVisitMethods(token: Token.StateToken): String {
        val expansions = grammarInfo.getGrammar().RULES[token].expansions
        return if (expansions.size == 1) {
            """
    /**
    $token -> ${expansions.first()}
    */
    fun visit_${token}(node: ${getNodeType(token)}): PrefixVisitorInfoData"""
        } else {
            """
    fun visit_${token}(node: ${getNodeType(token)}): PrefixVisitorInfoData {
        return when (val id = node.getExpansion().getId()) {
${expansions.joinToString("\n") { "\t\t\t${it.getId()} -> visit_${token}_${it.getId()}(node)" }}
            else -> throw IllegalStateException("Unexpected expansion id ${"$"}id in expansion of $token")
        }
    }
${expansions.joinToString("\n") {
                """
    /**
    $token -> $it
    */
    fun visit_${token}_${it.getId()}(node: ${getNodeType(token)}): PrefixVisitorInfoData"""
            }}"""
        }
    }

    private fun getTerminalVisitMethods(token: Token): String {
        return """
    fun visit_${token}(node: ${getNodeType(token)}): PrefixVisitorInfoData {
        return visitTerminal(node.getToken())
    }"""
    }
    
    override fun getAll(): String {
        return Beautifier.detabify(
            """/**
This code is generated by [${PrefixVisitorInfo::class.qualifiedName}] derived from [${VisitorInfo::class.qualifiedName}]
based on grammar description [translate.meta.MetaGrammarInfo] derived from [${GrammarInfo::class.qualifiedName}]
*/

package $packageName

import ${Visitor::class.qualifiedName}
import ${ASTNode::class.qualifiedName}
import ${Token::class.qualifiedName}
import $packageName.${grammarInfo.getName()}

@Suppress("UNCHECKED_CAST")
interface $className : ${Visitor::class.simpleName}<PrefixVisitorInfoData> {

/*
${grammarInfo.getGrammar()}
*/

    override fun visit(node: ASTNode<out Token>): PrefixVisitorInfoData {${getChoiceVisit()}
    }
    
    fun <T : Token> visitTerminal(token: T): PrefixVisitorInfoData
    
${getVisitMethods()}

}"""
        )
    }
    

}
