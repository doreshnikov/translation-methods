tokens {

    skip {
        WHITESPACE  : r'[ \r\n\t]' ;
    }

    fragments {
        LETTER  : r'[a-zA-Z]' ;
        DIGIT   : r'[0-9]' ;
        FIRST   : r'($LETTER|_)' ;
    }

    IF      : 'if' ;
    FOR     : 'for' ;
    PASS    : 'pass' ;
    BOTH    : 'both' ;
    PRINT   : 'print' ;

    PLUS    : '+' ;
    MINUS   : '-' ;
    TIMES   : '*' ;
    DIV     : '/' ;

    NOT     : '!' ;
    XOR     : '^' ;
    AND     : '&' ;
    OR      : '|' ;

    GE      : '>=' ;
    GT      : '>' ;
    LE      : '<=' ;
    LT      : '<' ;
    EQ      : '==' ;
    NE      : '!=' ;

    ASSIGN  : '=' ;

    VAR     : r'$FIRST($FIRST|$DIGIT)*' ;
    UINT    : r'$DIGIT*' ;

}

macro {

    fun tab(depth : Int) {
        return "\t".repeat(depth)
    }

}

grammar {

    companion {

        synthesis : {
            view : String :: { default = @1.view } ;
        }
        inheritance : {
            depth : Int :: { default = @.depth } ;
        }
        compute : {
            tab : String = @macro.tab(depth) ;
        }

        start : main ;

    }

    main        : code EOF :: { view = "fun main() {\n${@1.view}}\n" ;

    code        : codeBlock{ depth = 1 } code :: { view = "${@1.view}${@2.view}" }
                | EPSILON :: { view = "" } ;
    codeBlock   : statement
                | ifBlock
                | forBlock
                | PASS :: { view = "\n" } ;

    statement :: { view = "$tab${@1.view}" }
                : print
                | assignment ;
    print       : PRINT expression :: { view = "print(${@2.view})\n" } ;
    assignment  : ASSIGN VAR expression { view = "$@2 = ${@3.view}\n" } ;

    ifBlock     : IF logicalExpression innerBody{ depth = @.depth + 1 } innerBody{ depth = @.depth + 1 } :: { view = "${tab}if (${@1.view}) {\n${@3.view}${tab}} else {\n${@4.view}${tab}}" } ;
    forBlock    : FOR VAR arithmeticAtom arithmeticAtom innerBody{ depth = @.depth + 1 } :: { view = "${tab}for ($@2 in ${@3.view}..${@4.view}) {\n${@5.view}${tab}}" ;
    innerBody   : codeBlock
                | BOTH codeBlock innerBody :: { view = "${@2.view}${@3.view}" } ;

    expression  : logicalExpression
                | arithmeticExpression ;

    // TODO : other stuff

}